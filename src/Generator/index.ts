import path from 'path';
// @ts-ignore - no types for prettier
import { format } from 'prettier';
import fs from 'fs-extra';
import { codeGenPreferences, prettier } from './config';
import Knex from 'knex';
import { MySQLIntrospection } from './Introspection/MySQLIntrospection';
import { TableClientBuilder } from './TableClientBuilder/TableClientBuilder';
import { Introspection } from './Introspection/IntrospectionTypes';
import { DatabaseSchema } from '../TypeTruth/TypeTruth';
import { TableSchemaBuilder } from './TableClientBuilder/TableSchemaBuilder';

// TODO:- options

function currentDateTime() {
    const d = new Date();
    return `${d.toLocaleDateString()} at ${d.toLocaleTimeString()}`;
}

/**
 * Write to a typescript file
 * @param content
 * @param directory
 * @param filename
 */
async function writeTypescriptFile(content: string, directory: string, filename: string) {
    const fileHeader = `
         /* Auto generated by Gybson (https://github.com/MattGson/Gybson) --- DO NOT MODIFY */
        
        /* eslint-disable */
    `;

    // append creates files if they don't exist - write overwrites contents
    await fs.appendFile(path.join(directory, filename), '');
    await fs.writeFile(
        path.join(directory, filename),
        format(fileHeader + content, { parser: 'typescript', ...prettier }),
    );
}

// **************************
// generate client libs
// **************************

/**
 * Build an entry point file
 * @param builders
 * @param outdir
 */
async function generateClientIndex(builders: TableClientBuilder[], outdir: string) {
    let index = ``;
    let clients = ``;
    for (let builder of builders) {
        index += `import ${builder.className} from './${builder.className}';`;
        clients += `${builder.className}: new ${builder.className}(),`;
    }
    index += `
        const Gybson = () => {
        return {${clients}};
        };
        export default Gybson;
        export type Gybson = ReturnType<typeof Gybson>;
    `;

    await writeTypescriptFile(index, outdir, 'index.ts');
}

/**
 * Generate the db clients for each table
 * @param db
 * @param outdir
 * @param libDir - relative location of the Gybson client lib
 */
async function generateClients(db: Introspection, outdir: string, libDir?: string): Promise<string[]> {
    const builders: TableClientBuilder[] = [];
    const tables = await db.getSchemaTables();

    const schema: DatabaseSchema = {};

    for (let table of tables) {
        const tblSchema = await new TableSchemaBuilder(table, db).buildTableDefinition();
        const builder = new TableClientBuilder({
            table,
            schema: tblSchema,
            dbIntrospection: db,
            options: { ...codeGenPreferences, libPath: libDir || 'gybson' },
        });
        schema[table] = tblSchema;
        builders.push(builder);
        await writeTypescriptFile(await builder.build(), outdir, `${builder.className}.ts`);
    }
    // ADD relation map
    await writeTypescriptFile(
        `
        import { DatabaseSchema } from '${libDir}';

        export const schema: DatabaseSchema = ${JSON.stringify(schema)}`,
        outdir,
        `schemaRelations.ts`,
    );

    // BUILD ENTRY POINT
    await generateClientIndex(builders, outdir);

    return tables;
}

// ****************************
// Entry point
// ****************************

export interface Connection {
    client: 'mysql' | 'postgres';
    connection: {
        host: string;
        port: number;
        user: string;
        password: string;
        database: string;
        multipleStatements?: boolean;
    };
}

export async function generate(conn: Connection, outdir: string, libDir?: string) {
    console.log(`Generating client for schema: ${conn.connection.database}`);

    const knex = Knex(conn);
    let DB: Introspection;

    if (conn.client === 'mysql') {
        DB = new MySQLIntrospection(knex, conn.connection.database);
    } else throw new Error('PostgreSQL not currently supported');

    const tables = await generateClients(DB, outdir, libDir);

    console.log(`Generated for ${tables.length} tables in ${outdir}`);
    await knex.destroy();
}

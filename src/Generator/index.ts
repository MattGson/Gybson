import path from 'path';
// @ts-ignore
import { format } from 'prettier';
import fs from 'fs-extra';
import { prettier, codeGenPreferences } from './config';
import Knex from 'knex';
import { MySQLIntrospection } from './Introspection/MySQLIntrospection';
import { TableClientBuilder } from './TableClientBuilder';
import { Introspection } from './Introspection/IntrospectionTypes';
import { TypeBuilder } from './TypeBuilder/TypeBuilder';

/**
 * Write to a typescript file
 * @param content
 * @param directory
 * @param filename
 */
async function writeTypescriptFile(content: string, directory: string, filename: string) {
    const fileHeader = `
         /* Auto generated by Nodent on ${Date.now().toLocaleString()} - DO NOT MODIFY */
        
        /* eslint @typescript-eslint/no-namespace: 0 */
        /* eslint  @typescript-eslint/class-name-casing: 0 */
    `;

    // append creates files if they don't exist - write overwrites contents
    await fs.appendFile(path.join(directory, filename), '');
    await fs.writeFile(
        path.join(directory, filename),
        format(fileHeader + content, { parser: 'typescript', ...prettier }),
    );
}

// **************************
// generate types
// **************************

async function generateTypes(db: Introspection, outdir: string): Promise<void> {
    // const DB = new MySQLIntrospection(knex, mysql.database);

    const tables = await db.getSchemaTables();
    const enums = await db.getEnumTypes();

    // const interfacePromises = tables.map((table) => typescriptOfTable(db, table, schema as string, optionsObject));
    // const interfaces = await Promise.all(interfacePromises).then((tsOfTable) => tsOfTable.join(''));
    //
    const typeBuilder = new TypeBuilder(tables, enums, codeGenPreferences);

    const types = await typeBuilder.build(db);
    //
    // // write index
    // await fs.writeFile(
    //     path.join(GENERATED_DIR, 'index.ts'),
    //     format(
    //         `
    //            import * as DBRowTypes from './db-schema';
    //            import { DBTables, DBTableName } from './db-tables';
    //            export { DBRowTypes, DBTableName, DBTables };
    //     `,
    //         { parser: 'typescript', ...prettier_conf },
    //     ),
    // );
    //
    // const rowTypes = await typeBuilder.generateRowTypes();
    // const tableTypes = await typeBuilder.generateTableTypes();

    await writeTypescriptFile(types, outdir, 'db-schema.ts');
}

// **************************
// generate loaders
// **************************

/**
 * Generate the db clients for each table
 * @param db
 * @param outdir
 */
async function generateClients(db: Introspection, outdir: string): Promise<string[]> {
    const builders: TableClientBuilder[] = [];

    const tables = await db.getSchemaTables();

    for (let table of tables) {
        const builder = new TableClientBuilder(table, codeGenPreferences);
        builders.push(builder);
        await writeTypescriptFile(await builder.build(db), outdir, `${builder.className}.ts`);
    }

    return tables;
}

interface Connection {
    client: 'mysql' | 'postgres';
    connection: {
        host: string;
        port: number;
        user: string;
        password: string;
        database: string;
    };
}

export async function generate(conn: Connection, outdir: string) {
    const knex = Knex(conn);
    let DB: Introspection;

    if (conn.client === 'mysql') {
        DB = new MySQLIntrospection(knex, conn.connection.database);
    } else throw new Error('PostgreSQL not currently supported');

    await generateTypes(DB, outdir);
    await generateClients(DB, outdir);

    await knex.destroy();
}

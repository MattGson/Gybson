import _ from 'lodash';
import { ColumnDefinition } from './types';

export class LoaderBuilder {
    public readonly EntName: string;
    public readonly RowTypeName: string;
    public readonly LoaderName: string;
    public readonly table: string;
    private loaders: string[] = [];

    public constructor(table: string) {
        this.EntName = LoaderBuilder.PascalCase(table);
        this.table = table;
        this.RowTypeName = `${this.EntName}DTO`;
        this.LoaderName = `${this.EntName}Loader`;
    }

    private static PascalCase(name: string) {
        return _.upperFirst(_.camelCase(name));
    }

    public compile(): string {
        return this.buildTemplate(
            this.loaders.join(`
        `),
        );
    }

    private buildTemplate(content: string) {
        return `
            /* Auto generated by GenLoader */
            /* DO NOT MODIFY */
        
            import DataLoader = require('dataloader');
            import { byColumnLoader, manyByColumnLoader, allLoader, findManyLoader } from '../Loaders';
            import { DBRowTypes, DBTables } from '../Types';
            
            export type ${this.RowTypeName} = DBRowTypes.${this.table};
            
             export default class ${this.LoaderName} {
                ${content}
            }
            `;
    }

    /**
     * Build a public interface for a loader
     * Can optionally include soft delete filtering
     * @param column
     * @param loaderName
     * @param hasSoftDelete
     */
    private loaderMethod(column: ColumnDefinition, loaderName: string, hasSoftDelete: boolean) {
        const { columnName, tsType } = column;

        if (hasSoftDelete)
            return `
            public async by${LoaderBuilder.PascalCase(columnName)}(${columnName}: ${tsType}, includeDeleted = false) {
                    const row = await this.${loaderName}.load(${columnName});
                    if (row?.deleted && !includeDeleted) return null;
                    return row;
                }
        `;

        return `
            public by${LoaderBuilder.PascalCase(columnName)}(${columnName}: ${tsType}) {
                    return this.${loaderName}.load(${columnName});
                }
        `;
    }

    /** // TODO:- add compound key loaders i.e. orgMembers.byOrgIdAndUserId()
     * Build a loader to load a single row for each key
     * Gives the caller choice on whether to include soft deleted rows
     * @param column
     * @param hasSoftDelete
     */
    public addByColumnLoader(column: ColumnDefinition, hasSoftDelete: boolean) {
        const { columnName } = column;
        const loaderName = `${this.EntName}By${LoaderBuilder.PascalCase(columnName)}Loader`;
        this.loaders.push(`
              /* Notice that byColumn loader might return null for some keys */
                 private readonly ${loaderName} = new DataLoader<${column.tsType}, ${this.RowTypeName} | null>(ids => {
                    return byColumnLoader('${this.table}', '${columnName}', ids, false);
                });
                
                ${this.loaderMethod(column, loaderName, hasSoftDelete)}
            `);
    }

    /**
     * Build a loader to load many rows for each key
     * At the moment, this always filters out soft deleted rows
     * @param column
     * @param hasSoftDelete
     */
    public addManyByColumnLoader(column: ColumnDefinition, hasSoftDelete: boolean) {
        const { columnName } = column;
        const loaderName = `${this.EntName}By${LoaderBuilder.PascalCase(columnName)}Loader`;

        this.loaders.push(`
                private readonly ${loaderName} = new DataLoader<${column.tsType}, ${this.RowTypeName}[]>(ids => {
                return manyByColumnLoader('${this.table}', '${columnName}', ids, ['${columnName}'], ${
            hasSoftDelete ? 'true' : 'false'
        });
             });
             
            ${this.loaderMethod(column, loaderName, false)}

        `);
    }

    /**
     * Build a loader to query rows from a table.
     * Doesn't use batching or caching as this is very hard to support.
     * Gives the option of including soft deleted rows
     * // TODO:-
     *     - cursor pagination,
     *     - ordering - multiple directions and columns?, remove string constants?
     *     - Joins (join filtering), eager load?
     *     type defs
     *      - import schemats project
     *      - gen more comprehensive types for each table i.e. SelectionSet
     *      - Split the type outputs by table maybe?)
     * @param hasSoftDelete
     */
    public addFindMany(hasSoftDelete: boolean) {
        this.loaders.push(`
            public findMany
            <Column extends Extract<keyof DBTables['${this.table}'],
             string>, Conditions extends Partial<DBTables['${this.table}']>>
             (options: {
            orderBy?: { columns: Column[]; asc?: boolean; desc?: boolean; };
            where?: Conditions;
            ${hasSoftDelete ? 'includeDeleted?: boolean' : 'includeDeleted?: false'}
            }): Promise<${this.RowTypeName}[]> {
                    return findManyLoader('${this.table}', options, ${hasSoftDelete ? 'true' : 'false'});
                }
        `);
    }
}

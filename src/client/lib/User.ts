/* Auto generated by Gybson (https://github.com/MattGson/Gybson) --- DO NOT MODIFY */

/* eslint-disable */

import { flatten, orderBy } from 'lodash';
import { DatabaseSchema, RelationDefinition, TransitiveRelationDefinition } from 'relational-schema';
import { Paginate, RecordAny } from '../../types';
import schema from '../../../test/tmp/relational-schema';
// export type users_permissions = 'ADMIN' | 'USER';
// export type users_subscription_level = 'BRONZE' | 'GOLD' | 'SILVER';

// export interface User {
//     user_id: number;
//     best_friend_id: number | null;
//     email: string;
//     first_name: string | null;
//     last_name: string | null;
//     password: string;
//     token: string | null;
//     permissions: users_permissions | null;
//     subscription_level: users_subscription_level | null;
//     deleted_at: Date | null;
// }

// export interface UserRequiredRow {
//     user_id?: number;
//     best_friend_id?: number | null;
//     email: string;
//     first_name?: string | null;
//     last_name?: string | null;
//     password: string;
//     token?: string | null;
//     permissions?: users_permissions | null;
//     subscription_level?: users_subscription_level | null;
//     deleted_at?: Date | null;
// }

// export interface UserColumnMap {
//     user_id: boolean;
//     best_friend_id: boolean;
//     email: boolean;
//     first_name: boolean;
//     last_name: boolean;
//     password: boolean;
//     token: boolean;
//     permissions: boolean;
//     subscription_level: boolean;
//     deleted_at: boolean;
// }

// export interface UserHasManyRelationFilter {
//     exists?: boolean;
//     where?: UserWhere;
//     whereEvery?: UserWhere;
// }

// export interface UserHasOneRelationFilter {
//     exists?: boolean;
//     where?: UserWhere;
// }

// export interface UserHasOneRequiredRelationFilter {
//     where?: UserWhere;
// }

// export interface UserWhere {
//     user_id?: number | NumberWhere;
//     best_friend_id?: number | NumberWhereNullable | null;
//     email?: string | StringWhere;
//     first_name?: string | StringWhereNullable | null;
//     last_name?: string | StringWhereNullable | null;
//     password?: string | StringWhere;
//     token?: string | StringWhereNullable | null;
//     permissions?: users_permissions | null;
//     subscription_level?: users_subscription_level | null;
//     deleted_at?: Date | DateWhereNullable | null;

//     AND?: Enumerable<UserWhere>;
//     OR?: Enumerable<UserWhere>;
//     NOT?: Enumerable<UserWhere>;

//     best_friend?: UserHasOneRelationFilter | null;
//     author_posts?: PostHasManyRelationFilter | null;
//     users?: UserHasManyRelationFilter | null;
//     co_author_posts?: PostHasManyRelationFilter | null;
//     team_members?: TeamMemberHasManyRelationFilter | null;
// }

// export interface UserLoadOneWhere {
//     email?: string;
//     token?: string;
//     user_id?: number;
// }

// export interface UserLoadManyWhere {
//     best_friend_id?: number | null;
//     first_name?: string | null;
//     last_name?: string | null;
//     password?: string;
//     permissions?: users_permissions | null;
//     subscription_level?: users_subscription_level | null;
//     deleted_at?: Date | null;
// }

// export type UserOrderBy = {
//     user_id?: Order;
//     best_friend_id?: Order;
//     email?: Order;
//     first_name?: Order;
//     last_name?: Order;
//     password?: Order;
//     token?: Order;
//     permissions?: Order;
//     subscription_level?: Order;
//     deleted_at?: Order;
// };

// export interface UserPaginate {
//     limit?: number;
//     afterCursor?: Partial<User>;
//     beforeCursor?: Partial<User>;
//     offset?: number;
// }

// export class UserClient extends QueryClient<
//     User,
//     UserColumnMap,
//     UserWhere,
//     UserLoadOneWhere,
//     UserLoadManyWhere,
//     UserOrderBy,
//     UserPaginate,
//     UserRequiredRow
// > {
//     constructor(params: { knex: Knex<any, unknown>; logger: winston.Logger; engine: ClientEngine }) {
//         const { knex, logger, engine } = params;
//         super({
//             tableName: 'users',
//             schema: schema as any,
//             knex,
//             logger,
//             engine,
//         });
//     }
// }

// interface FluentPost {
//     first: () => Promise<string>;
//     comments: () => Promise<FluentComment>;
// }

// interface FluentComment {
//     first: () => Promise<string>;
// }

// interface FluentUser {
//     doc: string[];
//     posts: (url: string, date: number) => Promise<FluentPost>;
//     first: () => Promise<string>;
//     all: (imit?: number) => Promise<string[]>;
// }

// FIxed

interface Link {
    rootLoad?: 'uniq' | 'many';
    table: string;
    relation?: RelationDefinition | TransitiveRelationDefinition; // identifier for the relation that links to the parent
    options: {
        where?: RecordAny;
        orderBy?: RecordAny;
        includeDeleted?: boolean;
    };
    // nested relations to include
    with?: Link[];
    paginate?: Paginate;
}

class Trav {
    constructor() {}

    private taversalChain: Link[] = [];
    // maintain a pointer to current link for ease of use
    private currentLink: Link | undefined;

    // private getClient(type: string): QueryClient<any, any, any, any, any, any, any, any> {
    private getClient(type: string) {
        // return new UserClient({});
        return {
            // can probably generalise loadOne, loadMany, findMany into a generic batch loader which performs all optimisations possible
            batchFind(args: { where?: any; orderBy?: any; includeDeleted?: boolean }) {
                switch (type) {
                    case 'users':
                        console.log('BATCH FIND users with: ', args);
                        return [
                            {
                                user_id: 12,
                                name: 'john',
                            },
                            {
                                user_id: 21,
                                name: 'john',
                            },
                        ];
                    case 'posts':
                        console.log('BATCH FIND posts with: ', args);
                        return [
                            {
                                post_id: 4,
                                user_id: 10,
                            },
                        ];
                    case 'comments':
                        console.log('BATCH FIND comments with: ', args);
                        return [
                            {
                                id: 4,
                            },
                        ];
                }
                return [{}];
            },
            findMany(_args: { whereIn: any[]; where: any }) {
                return [];
            },
        };
    }

    public pushLink(link: Link) {
        this.taversalChain.push(link);
        this.currentLink = link;
    }

    public addWith(withClause: Link) {
        if (!this.currentLink) throw new Error('No links in traversal yet, cannot add nested relation');
        this.currentLink.with ? this.currentLink.with.push(withClause) : (this.currentLink.with = [withClause]);
    }

    // public addWith(with: RecordAny) {
    // const with = this.traversalChain?.[this.traversalChain.length -1].with
    //     this.traversalChain?.[this.traversalChain.length -1].with
    // }

    /**
     * Resolve the fluent traversal chain
     * Iteratively executes the tree layer by layer
     * Database round-trips is O(N) where N is length of chain
     * This complexity extends to parallel executions of the same edges/nodes by a different Traveral instance
     *  i.e. parallel resolve trees in a GraphQL API
     */
    public async resolve<T>(): Promise<T[]> {
        // load the chain layer by layer

        // result from last edge traversal
        let prevResult: RecordAny[] = [];

        // parent link in the traveral chain (easier to memoize than to search)
        let parentLink: Link | null = null;

        for (const link of this.taversalChain) {
            console.log('Load link ', link);

            let result: RecordAny[] = [];
            const client = this.getClient(link.table);

            if (parentLink == null) {
                // loading the root of the tree

                if (!link.rootLoad) throw new Error('Please read the instructions!');

                result = await client.batchFind({
                    where: link.options?.where,
                    includeDeleted: link.options?.includeDeleted ?? undefined,
                });

                // if (link.rootLoad === 'uniq') {
                //     result = [
                //         await client.loadOne({
                //             where: {
                //                 ...(link.options.where ?? {}),
                //             },
                //             includeDeleted: link.options?.includeDeleted ?? undefined,
                //         }),
                //     ];
                // }
                // if (link.rootLoad === 'many') {
                //     result = await client.loadMany({
                //         ...link.options,
                //     });
                // }
            } else {
                // traversing an edge

                if (parentLink == null) throw new Error('Impossible'); // keeping the type checker happy

                let loads: any = [];

                // get relationship info - note this is the relationship from parent table
                const relationship = link.relation;
                if (!relationship) throw new Error(`Relationship not found between ${link.table} && ${parentLink.table}`);

                // transitive edges must be loaded in 2 steps
                if (relationship?.type === 'manyToMany') {
                    // for (const resolve of prev) {
                    //     let filter = node.filter?.where ?? {};
                    //     for (const join of relationship.joinFrom) {
                    //     }
                    //     transitiveResolves.push(
                    //         cl.loadMany({
                    //             where: {
                    //                 ...(node.filter?.where ?? {})
                    //             },
                    //         }),
                    //     );
                    // }
                }
                if (relationship?.type === 'belongsTo' || relationship.type === 'hasMany' || relationship.type === 'hasOne') {
                    // alternative 1 - global batching
                    // TODO:- note the problem here,  would require in mem sort to guarantee global order...

                    // load relations for each previous node (fan out graph traversal)
                    loads = await Promise.all(
                        prevResult.map(async (ent) => {
                            let filters = link.options.where ?? {};

                            // build the join key filters

                            relationship.joins.map((j) => {
                                filters[j.toColumn] = ent[j.fromColumn];
                            });

                            return client.batchFind({
                                // how to handle filters that are not batchable?
                                where: filters,
                                includeDeleted: link.options.includeDeleted,
                                // how to handle global ordering?
                                // maybe should batch these loads internally?

                                orderBy: link.options.orderBy,
                            });
                        }),
                    );
                    result = flatten(await Promise.all(loads));

                    // alternative 2 - within chain batching
                    // can be applied to more complex filters like gt, like etc
                    // works because we can guarantee all filters other than joins are the same constants within all nodes in chain

                    const sharedFilters = link.options.where ?? {};

                    // build the join key filters

                    const inFilters = prevResult.map((ent) => {
                        let filters: any = {};
                        relationship.joins.map((j) => {
                            filters[j.toColumn] = ent[j.fromColumn];
                        });
                        return filters;
                    });

                    // need the stable multi-column where-in logic here
                    result = await client.findMany({ whereIn: inFilters, where: sharedFilters });
                }
            }
            parentLink = link;
            prevResult = result;
            console.log('LINK RESULT ', result);
        }
        // last link will be the correct result
        return prevResult as T[];
    }
}

// Generate
interface Post {
    post_id: number;
}

interface Comment {
    id: number;
}

interface User {
    user_id: number;
}

interface PostWhere {
    post_id: number;
}

interface CommentWhere {
    id: number;
}

interface UserWhere {
    user_id: number;
}

// TODO:- useable types
interface PostRelationMap {
    comments?: boolean;
    author?: boolean;
}

type PostWith = {
    comments: Comment[];
    author: User;
};

// interface paginate<T> {
//     (args: Paginate<T>): void;
// }

export function paginate<T>(args: Paginate<T>) {
    return args;
}

export abstract class FluentInterface<T> {
    protected relationMap = new Map<string, RelationDefinition | TransitiveRelationDefinition>();
    constructor(protected traversal: Trav, protected schema: DatabaseSchema, protected tableName: string) {
        schema.tables[tableName].relations.forEach((r) => {
            this.relationMap.set(r.alias, r);
        });
    }

    async first(): Promise<T | null> {
        const result = await this.traversal.resolve<T>();
        return result?.[0] ?? null;
    }
    async get(_args: { first?: number; after?: string }): Promise<T[]> {
        return await this.traversal.resolve<T>();
    }
}

type FluentExecutors = 'first' | 'get';
type PostChainables = 'comments' | 'topComment' | 'author';
type CommentChainables = 'author';

export class PostFluent<T = Post> extends FluentInterface<T> {
    where(_args?: PostWhere): PostFluent<T> {
        // additive where like knex
        // this.traversal.
        return this;
    }

    // TODO:- completest example
    // long return ype but basically just helping the user out.
    // - It makes not sense to add a withX clause other than at the end of chain
    // - makes no sense to use same with twice
    // so we remove all chainables and this method
    // TODO:- should we remove nested chainables? Or is that a feature? Enrich with arbritrary data?
    // TODO:- how to chain the Omit?
    withComments(
        chain?: (c: Omit<CommentFluent, FluentExecutors | CommentChainables>) => FluentInterface<any>,
    ): Omit<PostFluent<T & { comments: Comment[] }>, 'withComments' | PostChainables> {
        this.traversal.addWith({
            table: 'comments',
            // need to use the correct relation in case there are multiple relations to the same table
            // TODO:- should do this for where filters as well?
            relation: this.relationMap.get('comments'),
            options: {
                where: args?.where,
            },
            mixin: chain,
            paginate,
        });
        // no point recreating it
        return this as unknown as PostFluent<T & { comments: Comment[] }>;
    }

    // Note:- small interface improvement - remove methods that can't sensibly be used more than once
    withAuthor(args?: { where?: { name?: string } }): Omit<PostFluent<T & { author: User }>, 'withAuthor'> {
        this.traversal.addWith({
            table: 'users',
            // need to use the correct relation in case there are multiple relations to the same table
            // TODO:- should do this for where filters as well?
            relation: this.relationMap.get('author'),
            options: {
                where: args?.where,
            },
        });
        // no point recreating it
        return this as unknown as PostFluent<T & { author: User }>;
    }

    comments(args?: { where?: CommentWhere }) {
        this.traversal.pushLink({
            table: 'comments',
            relation: this.relationMap.get('comments'),
            options: {
                where: args?.where,
            },
        });
        return new CommentFluent(this.traversal, this.schema);
    }
    topComment(args?: { where?: CommentWhere }) {
        this.traversal.pushLink({
            table: 'comments',
            // need to use the correct relation in case there are multiple relations to the same table
            // TODO:- should do this for where filters as well?
            relation: this.relationMap.get('top_comment'),
            options: {
                where: args?.where,
            },
        });
        return new CommentFluent(this.traversal, this.schema);
    }
    author(args?: { where?: UserWhere }): UserFluent {
        this.traversal.pushLink({
            table: 'users',
            relation: this.relationMap.get('author'),
            options: {
                where: args?.where,
            },
        });
        return new UserFluent(this.traversal, this.schema);
    }

    constructor(traversal: Trav, schema: DatabaseSchema) {
        super(traversal, schema, 'posts');
    }
}

export class CommentFluent<T = Comment> extends FluentInterface<Comment> {
    where(_args?: CommentWhere): CommentFluent<T> {
        // this.traversal.
        return this;
    }
    orderBy(_args: { id: 'desc' }): CommentFluent<T> {
        // this.traversal.
        return this;
    }
    withAuthor(): CommentFluent<T & { author: User }> {
        this.traversal.addWith({
            table: 'users',
            // need to use the correct relation in case there are multiple relations to the same table
            // TODO:- should do this for where filters as well?
            relation: this.relationMap.get('author'),
            options: {
                where: args?.where,
            },
        });
        // no point recreating it
        return this as unknown as CommentFluent<T & { author: User }>;
    }
    post(args?: { where?: PostWhere }): PostFluent {
        this.traversal.pushLink({
            table: 'posts',
            relation: this.relationMap.get('post'),
            options: {
                where: args?.where,
            },
        });
        return new PostFluent(this.traversal, this.schema);
    }
    author(args?: { where?: UserWhere }): UserFluent {
        this.traversal.pushLink({
            table: 'users',
            relation: this.relationMap.get('author'),
            options: {
                where: args?.where,
            },
        });
        return new UserFluent(this.traversal, this.schema);
    }

    constructor(traversal: Trav, schema: DatabaseSchema) {
        super(traversal, schema, 'users');
    }
}

export class UserFluent<T = User> extends FluentInterface<User> {
    where(_args?: UserWhere): UserFluent<T> {
        // this.traversal.
        return this;
    }
    whereUnique(_args?: UserWhere): UserFluent<T> {
        // this.traversal.
        return this;
    }

    withFriends(_args?: { where?: { name?: string } }): Omit<UserFluent<T & { friends: User[] }>, 'withBadges'> {
        return this as unknown as UserFluent<T & { friends: User[] }>;
    }

    withBadges(_args?: { where?: { level?: { gt?: number; equals?: number } } }): Omit<UserFluent<T & { badges: User[] }>, 'withBadges'> {
        return this as unknown as UserFluent<T & { badges: User[] }>;
    }

    authorPosts(args?: { where?: PostWhere }): PostFluent {
        this.traversal.pushLink({
            table: 'posts',
            relation: this.relationMap.get('author_posts'),
            options: {
                where: args?.where,
            },
        });
        return new PostFluent(this.traversal, this.schema);
    }

    constructor(traversal: Trav, schema: DatabaseSchema) {
        super(traversal, schema, 'users');
    }
}

// Placeholder for UserClient class
// unique and find replace findMany and loadOne

class UserClientD {
    // unique(args: {
    //     where: {
    //         user_id?: number;
    //     };
    // }): UserFluent {
    //     const { where } = args;
    //     const traversal = new Trav();
    //     traversal.pushLink({
    //         rootLoad: 'uniq', // TODO:- does not matter?
    //         table: 'users',
    //         options: {
    //             where,
    //         },
    //     });
    //     return new UserFluent(traversal, schema as unknown as DatabaseSchema);
    // }

    find(args?: { includeDeleted?: boolean; skipCache?: boolean }): UserFluent {
        const traversal = new Trav();
        traversal.pushLink({
            rootLoad: 'many',
            table: 'users',
            options: {
                includeDeleted: args?.includeDeleted,
            },
        });
        return new UserFluent(traversal, schema as unknown as DatabaseSchema);
    }

    from(data: User | null): UserFluent {
        const traversal = new Trav();
        traversal.pushLink({
            // rootLoad: 'many',
            rootData: data, // avoid re-loading same data?
            table: 'users',
            options: {},
        });
        return new UserFluent(traversal, schema as unknown as DatabaseSchema);
    }
}

const client = { user: new UserClientD() };

// const de = user
//     .find({ where: { user_id: 1 } })
//     .first()
//     .then((u) => console.log(u));

// const dev1 = user
//     .find({ where: { name: 'john' } })
//     .authorPosts({ where: { post_id: 3 } })
//     .withComments({ orderBy: { id: 'desc' } }, paginate({ limit: 10, afterCursor: { id: 1 } }))
//     .withAuthor()
//     .first()
//     .then((r) => console.log(r));

// const dev = user
//     .find({ where: { name: 'john' } })
//     .authorPosts({ where: { post_id: 3 } })
//     // this pattern doesn't really make sense, no difference between function and raw object,
//     // would only make sense if could be given in any order?
//     .withComments({ orderBy: { id: 'desc' } }, paginate({ limit: 10, afterCursor: { id: 1 } }))
//     .author()
//     // clean but nested with?
//     .withFriends({ where: { name: 'steve' } })
//     // TODO:- how to batch this kind of filter? Within query should work, just need rules to distinguish this
//     .withBadges({ where: { level: { gt: 10 } } });

// dev.get({ first: 10 }).then((u) => console.log(u));

// const b = client.user
//     .find()
//     .authorPosts()
//     .where({
//         post_id: 3,
//     })
//     .withAuthor()
//     .get({ first: 10 });

// // fully fluent
// const c = q
//     .comments()
//     .where({ title: 'test' })
//     .withAuthor()
//     .withLikes((t) =>
//         t
//             .where({ count: 4 })
//             .paginate({
//                 first: 10,
//                 after: { id: 1 },
//             })
//             .withAuthor((a) => a.where({ id: 1 }).paginate({ first: 3 })),
//     )
//     .first();

async function test() {
    const author = await client.user.find({ skipCache: true, includeDeleted: true }).whereUnique({ user_id: 1 }).first();

    const posts = client.user
        .from(author)
        .authorPosts()
        .where({ post_id: 1 })
        .withComments((c) => c.where().orderBy({ id: 'desc' }));

    if (1 == 1) {
        posts.where({ post_id: 4 });
    }
    posts.withAuthor();
}

// const be = user
//     .unique({ where: { user_id: 1 } })
//     .posts({ where: { post_id: 3 } })
//     .comments()
//     .get({ first: 10, after: '3' })
//     .then((u) => console.log(u));

// const be2 = user
//     .find({ where: { name: 'john' } })
//     .posts()
//     .comments()
//     .first()
//     .then((u) => console.log(u));

// TODO:- don't ever need to load first item in chain if no filters?
// const contUser = gybson.comment.from(be2).author(...);

// // const t = proxy(UserFluent);

// // const z = t.posts('bbd', 88).first();

// .first()
// .then((p) => console.log(p));

const query = client.user.find().where({ user_id: 1 });

// query building support - will require a deep merge https://lodash.com/docs/4.17.15#merge
if (1 == 1) {
    query.where({
        user_id: 3,
    });
}

const data = client.user
    .find()
    .where({ user_id: 1 })
    .first()
    .then((u) => {
        return client.user.from(data).authorPosts().get({});
    })
    .then((p) => console.log(p));

const posts = client.user.from(data);

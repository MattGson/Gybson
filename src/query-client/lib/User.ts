/* Auto generated by Gybson (https://github.com/MattGson/Gybson) --- DO NOT MODIFY */

/* eslint-disable */

import { ClientEngine, Paginate, RecordAny } from '../../types';

import schema from './relational-schema';
import { Knex } from 'knex';
import winston from 'winston';

import {
    QueryClient,
    Order,
    Enumerable,
    NumberWhere,
    NumberWhereNullable,
    StringWhere,
    StringWhereNullable,
    BooleanWhere,
    BooleanWhereNullable,
    DateWhere,
    DateWhereNullable,
    Loader,
} from '../../query-client';

import { PostHasOneRelationFilter, PostHasManyRelationFilter, PostHasOneRequiredRelationFilter } from './Post';
import {
    TeamMemberHasOneRelationFilter,
    TeamMemberHasManyRelationFilter,
    TeamMemberHasOneRequiredRelationFilter,
} from './TeamMember';
import { GybsonClient } from '.';
import { DatabaseSchema } from 'relational-schema';

export type users_permissions = 'ADMIN' | 'USER';
export type users_subscription_level = 'BRONZE' | 'GOLD' | 'SILVER';

export interface User {
    user_id: number;
    best_friend_id: number | null;
    email: string;
    first_name: string | null;
    last_name: string | null;
    password: string;
    token: string | null;
    permissions: users_permissions | null;
    subscription_level: users_subscription_level | null;
    deleted_at: Date | null;
}

export interface UserRequiredRow {
    user_id?: number;
    best_friend_id?: number | null;
    email: string;
    first_name?: string | null;
    last_name?: string | null;
    password: string;
    token?: string | null;
    permissions?: users_permissions | null;
    subscription_level?: users_subscription_level | null;
    deleted_at?: Date | null;
}

export interface UserColumnMap {
    user_id: boolean;
    best_friend_id: boolean;
    email: boolean;
    first_name: boolean;
    last_name: boolean;
    password: boolean;
    token: boolean;
    permissions: boolean;
    subscription_level: boolean;
    deleted_at: boolean;
}

export interface UserHasManyRelationFilter {
    exists?: boolean;
    where?: UserWhere;
    whereEvery?: UserWhere;
}

export interface UserHasOneRelationFilter {
    exists?: boolean;
    where?: UserWhere;
}

export interface UserHasOneRequiredRelationFilter {
    where?: UserWhere;
}

export interface UserWhere {
    user_id?: number | NumberWhere;
    best_friend_id?: number | NumberWhereNullable | null;
    email?: string | StringWhere;
    first_name?: string | StringWhereNullable | null;
    last_name?: string | StringWhereNullable | null;
    password?: string | StringWhere;
    token?: string | StringWhereNullable | null;
    permissions?: users_permissions | null;
    subscription_level?: users_subscription_level | null;
    deleted_at?: Date | DateWhereNullable | null;

    AND?: Enumerable<UserWhere>;
    OR?: Enumerable<UserWhere>;
    NOT?: Enumerable<UserWhere>;

    best_friend?: UserHasOneRelationFilter | null;
    author_posts?: PostHasManyRelationFilter | null;
    users?: UserHasManyRelationFilter | null;
    co_author_posts?: PostHasManyRelationFilter | null;
    team_members?: TeamMemberHasManyRelationFilter | null;
}

export interface UserLoadOneWhere {
    email?: string;
    token?: string;
    user_id?: number;
}

export interface UserLoadManyWhere {
    best_friend_id?: number | null;
    first_name?: string | null;
    last_name?: string | null;
    password?: string;
    permissions?: users_permissions | null;
    subscription_level?: users_subscription_level | null;
    deleted_at?: Date | null;
}

export type UserOrderBy = {
    user_id?: Order;
    best_friend_id?: Order;
    email?: Order;
    first_name?: Order;
    last_name?: Order;
    password?: Order;
    token?: Order;
    permissions?: Order;
    subscription_level?: Order;
    deleted_at?: Order;
};

export interface UserPaginate {
    limit?: number;
    afterCursor?: Partial<User>;
    beforeCursor?: Partial<User>;
    offset?: number;
}

export class UserClient extends QueryClient<
    User,
    UserColumnMap,
    UserWhere,
    UserLoadOneWhere,
    UserLoadManyWhere,
    UserOrderBy,
    UserPaginate,
    UserRequiredRow
> {
    constructor(params: { knex: Knex<any, unknown>; logger: winston.Logger; engine: ClientEngine }) {
        const { knex, logger, engine } = params;
        super({
            tableName: 'users',
            schema: schema as any,
            knex,
            logger,
            engine,
        });
    }
}

interface FluentPost {
    first: () => Promise<string>;
    comments: () => Promise<FluentComment>;
}

interface FluentComment {
    first: () => Promise<string>;
}

// interface FluentUser {
//     doc: string[];
//     posts: (url: string, date: number) => Promise<FluentPost>;
//     first: () => Promise<string>;
//     all: (imit?: number) => Promise<string[]>;
// }

export class PostFluent {
    constructor(private traversal: Trav) {}

    private doc = [];

    comments() {
        return {
            first() {
                return Promise.resolve('comment');
            },
        };
    }

    async first() {
        return this.doc[0];
    }
    async all(limit?: number) {
        return this.doc.slice(0, limit ?? 10);
    }
}

export class UserFluent {
    constructor(private traversal: Trav) {}

    private doc = [];

    posts(params?: { where?: { age: number } }): PostFluent {
        this.doc = [];
        return new PostFluent(this.traversal);
    }
    async first() {
        return this.doc[0];
    }
    async all(limit?: number) {
        return this.doc.slice(0, limit ?? 10);
    }
}

interface Link {
    rootLoad?: 'one' | 'many';
    type: 'User' | 'Post' | 'Comment';
    options: {
        where: RecordAny;
        orderBy?: RecordAny;
        includeDeleted?: boolean;
    };
    with?: RecordAny;
    paginate?: Paginate;
}

class Trav {
    constructor(private schema: DatabaseSchema) {}

    private taversalChain: Link[] = [];

    private getClient(type: string): QueryClient<any, any, any, any, any, any, any, any> {
        // return new UserClient({});
    }

    /**
     * Resolve the fluent traversal chain
     * Iteratively executes the tree layer by layer
     * Database round-trips is O(N) where N is length of chain
     * This complexity extends to parallel executions of the same edges/nodes by a different Traveral instance
     *  i.e. parallel resolve trees in a GraphQL API
     */
    public async resolve<T>(): Promise<T> {
        // load the chain layer by layer

        // result from last edge traversal
        let prevResult: RecordAny[] = [];

        // parent link in the traveral chain (easier to memoize than to search)
        let parentLink: Link | null = null;

        for (const link of this.taversalChain) {
            let result: RecordAny[] = [];
            const client = this.getClient(link.type);

            if (parentLink == null) {
                // loading the root of the tree

                if (!link.rootLoad) throw new Error('Please read the instructions!');
                if (link.rootLoad === 'one') {
                    result = [
                        await client.loadOne({
                            where: {
                                ...(link.options.where ?? {}),
                            },
                            includeDeleted: link.options?.includeDeleted ?? undefined,
                        }),
                    ];
                }
                if (link.rootLoad === 'many') {
                    result = await client.loadMany({
                        ...link.options,
                    });
                }
            } else {
                // traversing an edge

                if (parentLink == null) throw new Error('Impossible'); // keeping the type checker happy

                let loads: any = [];

                // get relationship info
                const relationship = this.schema.tables[link.type].relations.find(
                    (r) => r.toTable === parentLink!.type,
                );
                if (!relationship) throw new Error(`Relationship not found between ${link.type} && ${parentLink.type}`);

                // transitive edges must be loaded in 2 steps
                if (relationship?.type === 'manyToMany') {
                    // for (const resolve of prev) {
                    //     let filter = node.filter?.where ?? {};
                    //     for (const join of relationship.joinFrom) {
                    //     }
                    //     transitiveResolves.push(
                    //         cl.loadMany({
                    //             where: {
                    //                 ...(node.filter?.where ?? {})
                    //             },
                    //         }),
                    //     );
                    // }
                }
                if (
                    relationship?.type === 'belongsTo' ||
                    relationship.type === 'hasMany' ||
                    relationship.type === 'hasOne'
                ) {
                    // maybe should batch these internally?
                    loads = await Promise.all(
                        prevResult.map(async (ent) => {
                            let filters = link.options.where ?? {};

                            relationship.joins.map((j) => {
                                filters[j.fromColumn] = j.toColumn;
                            });
                            // treat all as many loads as there is pretty much no performance impact
                            const related = await client.loadMany({
                                where: {},
                            });
                        }),
                    );

                    // for (const resolve of prevResult) {
                    //     let filter = node.filter?.where ?? {};
                    //     for (const join of relationship?.joins) {
                    //     }
                    //     transitiveResolves.push(
                    //         cl.loadMany({
                    //             where: {
                    //                 ...(node.filter?.where ?? {}),
                    //             },
                    //         }),
                    //     );
                    // }
                }
                result = await Promise.all(loads);
            }
            parentLink = link;
            prevResult = result;
        }
    }
}
const user = () => new UserFluent({ taversal: [] });

const be = user()
    .posts({ where: { age: 1 } })
    .comments()
    .first();

const t = proxy(UserFluent);

const z = t.posts('bbd', 88).first();

// .first()
// .then((p) => console.log(p));
